{{/*
	This is triggered by the Soundboard -play, -skip commands.
	
	Recommended trigger: `none`.
*/}}

{{ $cc := toInt .CCID }}
{{ $current := "None" }}
{{ $timeA := 0 }}
{{ $upnext := "None" }}
{{ $timeB := 0 }}
{{ $global := 1 }}
{{ $cc := toInt .CCID }}
{{ $songs := dbGet $global "songs" }}
{{ $queue := dbGet 0 "queue" }}
{{ $channels := cslice 757620825691258880 }}

{{ with .ExecData }}

	{{ $embed := sdict .Embed }}
	{{ $embed.Set "fields" (cslice.AppendSlice $embed.fields) }}
	{{ $msgs := split $embed.description "\n" | cslice.AppendSlice }}

	{{ $embed.fields.Set (index (sdict "Current" 0 "Upnext" 1).Upnext) (sdict
		"name" $upnext
		"value" (printf "%d Seconds" $upnext.Length )
		"inline" true
	) }}

	{{ $data := sdict . }}
	{{ $data.Set "Current" .Current }}
	{{ $data.Set "Upnext" .Upnext }}
	{{ $data.Set .Current $upnext }}
	{{ $data.Set "Embed" $embed }}
	{{ $data.Set "Queue" $queue }}

	{{ if and (eq $timeA 0) (eq $upnext "None") }}
		{{ $current = "None" }}
		{{ exec "sbreset" }}
		{{ $msgs = $msgs.Append (printf "The soundboard is now over.") }}
	{{ end }}

	{{ if eq $current "None" }}
		{{ if dbGet $global "Queue" }}
		{{ $upnext = dbGet $global "Queue" }}{{ end }}
		{{ $current = $upnext }}
		{{ $timeB = $songs.Get $upnext }}
		{{ $timeA = dbSetExpire $global $current "songlength" $timeB }}
		{{ execCC $cc nil 2 $data }}
		{{ $upnext = $queued.queue }}
		{{ exec "sbreset" }}
		{{ exec "sb" $current }}
	{{ end }}

	{{ if gt $timeA 0 }}
		{{ execCC $cc (index $channels (randInt (len $channels))) 2 $data }}
	{{ end }}

 	{{ editMessage .ChannelID .MsgID (cembed $embed) }}
	{{ sleep $timeA }}
{{ end }}